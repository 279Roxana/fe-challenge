<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>problems05</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<p># Problem set 5</p>
<ul>
<li><p>Problem (CustomStringSort.java).</p>
<p>In this problem, starting from the code in the named .java file, you will write lambda expressions that allow for the comparison of pairs of Strings, and then use them to create customized methods for sorting ArrayLists of Strings. In particular, you will work with the following interface:</p>
<pre><code>  interface PredicateStringPair
  {
      boolean better( String a, String b );
  }</code></pre>
<p>In this problem, we will make use of <code>interface Comparator&lt;T&gt;</code> and one of the static methods <code>Collections.sort</code>; both of these are provided by Java, and you are asked to look at the Java API documentation for more information on these.</p>
<p>You are to implement the following methods, as described.</p>
<ul>
<li>Write a method</li>
</ul>
<pre><code>createComparator( PredicateStringPair pred )</code></pre>
<p>that returns an instance of <code>Comparator&lt;String&gt;</code>. The returned instance of <code>Comparator&lt;String&gt;</code> should receive two strings, which weâ€™ll call <code>a</code> and <code>b</code>, and return: a negative value when the <code>better</code> method of <code>pred</code> returns true on the pair <code>a, b</code>; a positive value when <code>better</code> returns true on the pair <code>b, a</code>; and, 0 otherwise. (We will only create instances of <code>PredicateStringPair</code> whose <code>better</code> method never returns true both on a pair <code>a, b</code> of Strings and on its transposition <code>b, a</code>.)</p>
<ul>
<li>Write a method</li>
</ul>
<pre><code>sortStrings( ArrayList&lt;String&gt; lst, PredicateStringPair pred )</code></pre>
<p>that calls <code>createComparator</code> on <code>pred</code> to obtain an instance of <code>Comparator&lt;String&gt;</code>, and then calls the built-in method <code>Collections.sort</code>, passing it both <code>lst</code> and the obtained instance of <code>Comparator&lt;String&gt;</code>.</p>
<ul>
<li>Write a method</li>
</ul>
<pre><code>sortStringsLonger( ArrayList&lt;String&gt; lst )</code></pre>
<p>that does the following. First, using a lambda expression, it defines an instance of <code>PredicateStringPair</code> whose method returns true on a pair of Strings <code>a, b</code> if and only if the length of <code>a</code> is strictly greater than the length of <code>b</code>. Then, it calls <code>sortStrings</code> on <code>lst</code> and the created instance of <code>PredicateStringPair</code>.</p>
<ul>
<li>Write a method</li>
</ul>
<pre><code>sortStringsNumAs( ArrayList&lt;String&gt; lst )</code></pre>
<p>that does the following. First, using a lambda expression, it defines an instance of <code>PredicateStringPair</code> whose method returns true on a pair of Strings <code>s1, s2</code> if and only if the number of occurrences of the letter <em>a</em> (in either upper or lower case) in <code>s1</code> is strictly greater than the number of such occurrences in <code>s2</code>. Then, it calls <code>sortStrings</code> on <code>lst</code> and the created instance of <code>PredicateStringPair</code>.</p>
<ul>
<li>Write a method</li>
</ul>
<pre><code>sortStringsDictionary( ArrayList&lt;String&gt; lst )</code></pre>
<p>that does the following. First, using a lambda expression, it defines an instance of <code>PredicateStringPair</code> whose method returns true on a pair of Strings <code>s1, s2</code> if and only if <code>s1</code> comes before <code>s2</code> according to <em>dictionary ordering</em>. Then, it calls <code>sortStrings</code> on <code>lst</code> and the created instance of <code>PredicateStringPair</code>.</p>
<p>Here, we define <em>dictionary ordering</em> as follows. To determine if <code>s1</code> comes before <code>s2</code>, scan them character-by-character from left-to-right, seeing if a mismatch is found, that is, seeing if one can find an index such that <code>s1</code> and <code>s2</code> differ at that index.</p>
<p>When no such mismatch can be found, then <code>s1</code> is considered to come before <code>s2</code> if and only if the length of <code>s1</code> is strictly less than the length of <code>s2</code>.</p>
<p>When a mismatch is found, consider the first index (starting from the left) where the two strings differ. If at that index <code>s1</code> contains a letter of the alphabet and <code>s2</code> does not, then <code>s1</code> comes before <code>s2</code>; analogously, if at that index <code>s2</code> contains a letter of the alphabet and <code>s1</code> does not, then <code>s1</code> does not come before <code>s2</code>. If both <code>s1</code> and <code>s2</code> contain letters of the alphabet at that index, then use the ordering <code>'a' &lt; 'A' &lt; 'b' &lt; 'B' &lt; 'c' &lt; 'C' &lt; ...</code>, that is, use normal alphabetical ordering, with the convention that a lowercase letter comes before its uppercase version. Finally, if neither <code>s1</code> nor <code>s2</code> contains a letter of the alphabet at that index, then use the normal ordering <code>&lt;</code> defined by Java on <code>char</code> values.</p>
<p>As examples of dictionary ordering: <code>abs</code> comes before <code>absolutely</code>; <code>absolutely</code> does not come before <code>abs</code>, and <code>abs</code> does not come before <code>abs</code>. The word <code>aardvark</code> comes before <code>abs</code>, but <code>abs</code> comes before <code>Aardvark</code>. The following list is such that each word comes (in dictionary ordering) before any other word if and only if the first word appears above the second word.</p>
<pre><code>  banana
  bananas
  Banana
  kiwis
  Kiwi
  strawberries
  Strawberry
  3 oranges
  33 oranges
  9 oranges
  @kumquat
  @plum       </code></pre></li>
</ul>
</body>
</html>
